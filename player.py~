import sys, time
import random as rnd
from collections import defaultdict
import numpy.random
poisson = numpy.random.poisson



class Player:
    def __init__(self, name=''):
        self.name = name
        self.game = None
        self.hand = []
        self.deck = []
        self.board = Board()
        self.domains = [Domain('Domain1'),
                        Domain('Domain2'),
                        Domain('Domain3')]
        self.discardPile = []
        
    #-- Reports
    def handReport(self):
        header = reportColor("%s's HAND\n" % self.name)
        return header + '\n'.join(map(repr,self.hand))

    def domainReport(self):
        header = reportColor("%s's DOMAINS\n" % self.name)
        return header +\
               '\n'.join(map(lambda d: d.report(), self.domains))

    def boardReport(self):
        header = reportColor("%s's BOARD\n" % self.name)
        return header + '\n'.join(map(repr,self.board.characters)) +\
                        '\n\n' +\
                        '\n'.join(map(repr,self.board.supports))

    def discardReport(self):
        header = reportColor("%s's DISCARD PILE\n" % self.name)
        return header + '\n'.join(map(repr,self.discardPile))

    def report(self):
        return '\n'.join([self.handReport(),
                          self.domainReport(),
                          self.discardReport()])


    #~~ Information
    def nCards(self):
        return len(self.hand)


    def opponent(self):
        players = self.game.players[:]
        players.remove(self)
        return players[0]

    def randHandCard(self):
        cardpos = rnd.choice(range(self.nCards()))
        return self.hand[cardpos]


    

    #~~ Actions
    def attach2Domain(self, card, domain):
        if card not in self.hand:
            raise KeyError("This card is not in your hand")
        elif domain not in self.domains:
            raise KeyError("This is not one of your domains")
        else:
            self.hand.remove(card)
            domain.resources.append(card)

    def commit(self, card, story):
        if card not in self.board.characters:
            raise KeyError("This character is not on your board")
        elif story not in self.game.stories:
            raise KeyError("This story is not on the board")
        elif card.isExhausted():
            raise KeyError("This character is exhausted. It cannot commit to a story.")
        else:
            self.board.characters.remove(card)
            card.exhaust()
            story.committed[self].append(card)

    def draw(self, n=1):
        for i in range(n):
            card = self.deck.pop()
            self.hand.append(card)

    def payCost(self, domain):
        if domain is None:
            pass # do not drain anything
        elif domain not in self.domains:
            raise KeyError("This domain does not belong to you")
        elif domain.isDrained():
            raise KeyError("This domain has already been drained")
        elif card.cost > domain.totalRes():
            print '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
            print 'cost',card.cost, '  domain tot', domain.totalRes()
            print card
            print domain.report()
            raise KeyError("This domain cannot afford this card")
        else:
            domain.drain()
        
    def play(self, card, domain):
        if hasattr(card, 'playtype'):
            move = card.playtype
        else:
            if isinstance(card, Character):
                move = self.playCharacterFromHand
            elif isinstance(card, Support):
                move = self.playBoardSupportFromHand
            elif isinstance(card, Event):
                move = self.playEventActionFromHand
        move(card, domain)

    def playBoardSupportFromHand(self, card, domain):
        self.playFromHand(card, domain)
        self.board.supports.append(card)

    def playCharacterFromHand(self, card, domain):
        self.playFromHand(card, domain)
        self.board.characters.append(card)
            
    def playEventActionFromHand(self, card, domain):
        self.playFromHand(card, domain)
        self.discardPile.append(card)

    def playFromHand(self, card, domain):
        # pays the cost and removes card from hand.
        # the card goes nowhere, you can't call this by itself.
        # it must be followed by code about where the card ends up.
        if card not in self.hand:
            raise KeyError("This card is not in your hand")
        elif card.cost == 0 and domain is not None:
            raise KeyError("Cannot drain a domain for 0 cost")
        else:
            self.payCost(domain)
            self.hand.remove(card)

    def wound(self, character):
        character.wounds += 1
        if character.wounds > character.toughness:
            self.destroy(character)

    def destroy(self, card):
        if card.controller != self:
            raise KeyError("You can only destroy cards under your control")
        # remove from current place
        if card.isOnBoard(self.board):
            self.board.remove(card)
        elif card.isInHand(self):
            self.hand.remove(card)
        else:
            raise KeyError("You cannot destroy that card")
        # put in your discard pile
        self.discardPile.append(card)
        
